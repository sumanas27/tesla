using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data;
using TeslaSQL.DataUtils;
using System.Text.RegularExpressions;

namespace TeslaSQL.Agents {
    /// <summary>
    /// This is a convenience class that binds a TError and a count for aggregate reporting.
    /// </summary>
    class AggregateError
    {
        public TError Error { get; set; }
        public int Count { get; set; }

        public AggregateError(TError error)
        {
            Error = error;
            Count = 1;
        }

    }

    /// <summary>
    /// This agent sends alerts that are generated by other agents.
    /// </summary>
    class Notifier : Agent {
        private IEmailClient emailClient;

        //base keyword invokes the base class's constructor
        public Notifier(IDataUtils dataUtils, IEmailClient emailClient, Logger logger)
            : base(dataUtils, null, logger) {
            this.emailClient = emailClient;
        }

        public override void ValidateConfig() {
            Config.ValidateRequiredHost(Config.RelayServer);
            if (Config.RelayType == SqlFlavor.None) {
                throw new Exception("Notifier agent requires a valid SQL flavor for relay");
            }
        }

        public override void Run() {
            IEnumerable<TError> errors = sourceDataUtils.GetUnsentErrors();
            List<AggregateError> aggregateErrors = new List<AggregateError>();
            var errorBlocks = new List<string>();
            errorBlocks.Add(Config.EmailMessage);
            var ids = new List<int>();

            //don't add an error to the e-mail if it happens a lot, just report the number of times it happened
            foreach (TError error in errors)
            {
                if (aggregateErrors.Exists(x => x.Error.logDate.Date == error.logDate.Date && x.Error.message == error.message))
                {
                    aggregateErrors.First(x => x.Error.logDate.Date == error.logDate.Date && x.Error.message == error.message).Count++;
                }
                else
                {
                    aggregateErrors.Add(new AggregateError(error));
                }
            }

            
            foreach (AggregateError aggError in aggregateErrors.OrderBy(x => x.Error.logDate)) {
                var blockBuilder = new StringBuilder();
                blockBuilder.Append("<div><p><span> ");
                blockBuilder.Append(aggError.Error.logDate);
                blockBuilder.Append(" </span><span>Count: ");
                blockBuilder.Append(aggError.Count);
                blockBuilder.Append("</span></p>");
                blockBuilder.Append("<p>");
                blockBuilder.Append(aggError.Error.headers);
                blockBuilder.Append("</p>");
                if (aggError.Error.message.StartsWith("Table:"))
                {
                    blockBuilder.AppendLine(aggError.Error.message.Substring(0, aggError.Error.message.IndexOf("\n", aggError.Error.message.IndexOf("\n") + 1)));
                }
                blockBuilder.AppendLine("</div><br/>");
                var block = blockBuilder.ToString();
                block = Regex.Replace(block, "\r?\n", "<br />");
                errorBlocks.Add(block);
                ids.Add(aggError.Error.id);
            }
            if (errorBlocks.Count == 0) {
                return;
            }
            emailClient.SendEmail(Config.EmailErrorRecipient, "Errors occurred during changetracking", "<html>" + string.Join("", errorBlocks) + "</html>");
            sourceDataUtils.MarkErrorsSent(ids);
        }
    }
}
